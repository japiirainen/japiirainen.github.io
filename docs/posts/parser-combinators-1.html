<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Joona Piirainen - Implementing parser combinators pt. 1</title>
    <link rel="stylesheet" type="text/css" href="../css/composeconference.css" />

    <!-- favicon stuff-->
    <link rel="icon" type="image/x-icon" href="../favicon.ico" />
  </head>
  <body>
    <header>
      <div class="heading">
        <div class="logo">
          <div style="float: left"></div>
          <div>
            <a href="../">japiirainen</a>
          </div>
        </div>
        <nav><a href="../">home</a> <a href="../about.html">about</a></nav>
      </div>
    </header>

    <main class="markdown-body" role="main">
      <h1>Implementing parser combinators pt. 1</h1>
      <div class="info">
  <em>Posted on January  9, 2022  by Joona </em><br /><br />
</div>

<p>One of the many strengts of haskell is the ability to easily embed other small languages (sometimes called EDSL, short for embedded domain specific language) inside it. One famous example of this is the family of libraries known as parser combinators. They aim to solve the task of parsing structured text into well-typed data-structures, and succeed in it quite beautifully. In this short series of blog posts I will show you how to implement a simple and usable parser combinator library. You can find the source code for the library we will develop <a href="https://github.com/japiirainen/microparser">here</a>. For real world use-cases you should propably just use <a href="https://hackage.haskell.org/package/megaparsec"><strong><em>megaparsec</em></strong></a>.</p>
<h1 id="microparser">MicroParser</h1>
<p>So now let’s build own own toy parser combinator library! We will call it <strong><em>MicroParser</em></strong>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MicroParser</span> <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> (<span class="dt">Alternative</span> (..))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (void)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Char</span> <span class="kw">as</span> <span class="dt">Char</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (intercalate)</span></code></pre></div>
<p>Let’s start by thinking what the type of a parser should be? Structurally a parser is a function which takes an input stream of characters and yields a parse tree by applying the parsing logic over the input stream of characters to build up a composite data structure.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ParseResult</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">ParseSuccess</span> <span class="op">!</span>a <span class="op">!</span><span class="dt">Int</span> <span class="dt">String</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">ParseFailure</span> [(<span class="dt">Int</span>, <span class="dt">String</span>)]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Parser</span> a </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Parser</span> {unParser </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">              ::</span> <span class="dt">Int</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- ^ offset</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- ^ input stream of characters</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">ParseResult</span> a</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>              }</span></code></pre></div>
<p>Our parser is polymorphic over the thing our parser should produce when successful. Internally our parser function takes an <code>Int</code> as it’s first argument, which represents the position of the character we are currently parsing. This is useful for reporting errors. Other than that the type is relatively straight forward. Let’s define a function for running a parser.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParser ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>runParser (<span class="dt">Parser</span> p) ts <span class="ot">=</span> <span class="kw">case</span> p <span class="dv">0</span> ts <span class="kw">of</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ParseSuccess</span> x _ _ <span class="ot">-&gt;</span> <span class="dt">Right</span> x</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ParseError</span> es <span class="ot">-&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> <span class="op">$</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Expecting &quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&gt;</span> intercalate</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot; OR &quot;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>          [ e <span class="op">&lt;&gt;</span> <span class="st">&quot; at position &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> i</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> (i, e) <span class="ot">&lt;-</span> es</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<p>Running a parser yields either a parse result when successful and an error message in the case of an error, which we represent here as a (somewhat) formatted string. In proper parser combinator libraries error handling is handled in more elegant and structured ways.</p>
<p>Now we have defined the basic structure of our library, but it is not very usable at this point. We have no convenient way of constructing parsers nor do we have any way of combining them. So clearly we need to do some more work. The power of parser combinators mostly come from the typeclass instances we define for our <code>Parser</code> type. Especially <code>Applicative</code> and <code>Alternative</code> in our case. Some parser combinator libraries encourage the usage of the syntactic sugar haskell provides for monads. We are not going to define a monad instance for our parser since we can do plenty without it.</p>
<p>To define <code>Applicative</code> and <code>Alternative</code> instances we need to first define <code>Functor</code> for out <code>Parser</code> type. Here is the <code>Functor</code> instance definition for our <code>Parser</code> type.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Parser</span> p) <span class="ot">=</span> <span class="dt">Parser</span> (\i ts <span class="ot">-&gt;</span> <span class="fu">fmap</span> f (p i ts))</span></code></pre></div>
<p>Now we can move on to the more interesting instances. Let’s start with Applicative.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Parser</span> (<span class="dt">ParseSuccess</span> x)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Parser</span> a <span class="op">&lt;*&gt;</span> <span class="dt">Parser</span> b <span class="ot">=</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Parser</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            ( \i ts <span class="ot">-&gt;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> f i ts <span class="kw">of</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">ParseError</span> es <span class="ot">-&gt;</span> <span class="dt">ParseError</span> es</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">ParseSuccess</span> x i' ts' <span class="ot">-&gt;</span> <span class="kw">case</span> g i' ts' <span class="kw">of</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">ParseError</span> es' <span class="ot">-&gt;</span> <span class="dt">ParseError</span> es'</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">ParseSuccess</span> x' i'' ts'' <span class="ot">-&gt;</span> <span class="dt">ParseSuccess</span> (x x') i'' ts''</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            )</span></code></pre></div>
<p>This might be a bit intimidating if you are unfamiliar with <code>Applicative</code>. I’ll not go through explaining <code>Applicatives</code> in detail here, since it’s out of the scope of this blog post, but I highly suggest learning what they are and to start building an intuition on when you should use them. <a href="https://wiki.haskell.org/Typeclassopedia#Applicative">Here</a> is a good starting point.</p>
<h3 id="alternatives">Alternatives</h3>
<p>Next we will define <code>Alternative</code>. Alternative is not as well known as typeclasses such as <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> but are super useful for our use-case, so I think it’s worth looking at them in a bit more detail. The <code>Alternative</code> typeclass has four members including <code>empty</code>, <code>some</code>, <code>many</code> and most importantly for us <code>&lt;|&gt;</code>. Let’s explore what <code>&lt;|&gt;</code> does. The <code>Maybe</code> data type is well known so I will use it for demostration purposes since most people know what it represents. For me the mental model for <code>&lt;|&gt;</code> is the following. “Try executing the left hand side function and if successful, return the result, otherwise return the result of calling the right hand side function”. (This mental model happens to work for <code>Maybe</code>, but is not always correct since the operator can have different effects on other data types.)</p>
<pre class="shell"><code>ghci&gt; Just 4 &lt;|&gt; Just 5
Just 4
ghci&gt; Just 4 &lt;|&gt; Nothing
Just 4
ghci&gt; Nothing &lt;|&gt; Just 4
Just 4
ghci&gt; Nothing &lt;|&gt; Nothing
Nothing</code></pre>
<p>But we are implementing parsers… how can we use this? Well we can express <strong><em>choice</em></strong> with it. Particulally we can think of it as saying “try parse this, then try parse this, then try parse this, and so on”. This might sound a bit abstract at this point. But will become clear when we are finished!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  empty <span class="ot">=</span> <span class="dt">Parser</span> (\_ _ <span class="ot">-&gt;</span> <span class="dt">ParseError</span> [])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Parser</span> f <span class="op">&lt;|&gt;</span> <span class="dt">Parser</span> g <span class="ot">=</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Parser</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      ( \i ts <span class="ot">-&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> f i ts <span class="kw">of</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            success<span class="op">@</span><span class="dt">ParseSuccess</span> {} <span class="ot">-&gt;</span> success</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">ParseError</span> errs0 <span class="ot">-&gt;</span> <span class="kw">case</span> g i ts <span class="kw">of</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>              success<span class="op">@</span><span class="dt">ParseSuccess</span> {} <span class="ot">-&gt;</span> success</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>              <span class="dt">ParseError</span> errs1 <span class="ot">-&gt;</span> <span class="dt">ParseError</span> (errs0 <span class="op">&lt;&gt;</span> errs1)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      )</span></code></pre></div>
<p>This instance definition actually follows the mental model quite clearly. “Run the first parser, if successful, return the results, otherwise run the second parser”.</p>
<p>We are getting closer. Almost all the hard work is now done and we can move on to the fun part.</p>
<h3 id="combinators">Combinators</h3>
<p>To wrap up the first part of this series of posts, we will define a fundamental combinator found in almost all of the parser combinator libraries, <code>satisfy</code>, and show a couple of use-cases for it. We will write <code>satisfy</code> in terms of a more general function called <code>satisfyMaybe</code>, which takes a description (used for error messages), a function from <code>Char</code> to a <code>Maybe</code> value indicating weather the character <strong><em>satisfies</em></strong> some condition or not.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">satisfyMaybe ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>satisfyMaybe descr p <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Parser</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    ( \i ts <span class="ot">-&gt;</span> <span class="kw">case</span> ts <span class="kw">of</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        (t <span class="op">:</span> ts') <span class="op">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> p t <span class="ot">-&gt;</span> <span class="dt">ParseSuccess</span> x (i <span class="op">+</span> <span class="dv">1</span>) ts'</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="dt">ParseError</span> [(i, descr)]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ot">satisfy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>satisfy descr p <span class="ot">=</span> satisfyMaybe descr (\t <span class="ot">-&gt;</span> <span class="kw">if</span> p t <span class="kw">then</span> <span class="dt">Just</span> t <span class="kw">else</span> <span class="dt">Nothing</span>)</span></code></pre></div>
<p>Once we have <code>satisfy</code> we can define various combinators based on it. We will start with one that parses any character, one that parses a <strong><em>specific</em></strong> character, one for parsing whitespace and finally one that parses a specific sequence of characters.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">anyChar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>anyChar <span class="ot">=</span> satisfy <span class="st">&quot;any character&quot;</span> (<span class="fu">const</span> <span class="dt">True</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>char c <span class="ot">=</span> void <span class="op">$</span> satisfy (<span class="fu">show</span> c) (<span class="op">==</span> c)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">spaces ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>spaces <span class="ot">=</span> void <span class="op">$</span> many (satisfy <span class="st">&quot;whitespace&quot;</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">isSpace</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>string [] <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>string (x <span class="op">:</span> xs) <span class="ot">=</span> char x <span class="op">*&gt;</span> string xs</span></code></pre></div>
<p>Here’s an example of how one might use these. Suppose we want to parse a key value pair into a <code>KV</code> data type.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | example kaye value pair</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">text ::</span> <span class="dt">String</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>text <span class="ot">=</span> <span class="st">&quot;key: value&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Data type we would like parse the text into</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">KV</span> <span class="ot">=</span> <span class="dt">KV</span> (<span class="dt">String</span>, <span class="dt">String</span>) <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>We can do this via the following parser. Here we leverage some of the combinators we defined previously.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pKv ::</span> <span class="dt">Parser</span> <span class="dt">KV</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>pKv <span class="ot">=</span> <span class="dt">KV</span> <span class="op">&lt;$&gt;</span> parseKv</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    parseKv <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> many alpha <span class="op">&lt;*</span> char <span class="ch">':'</span> <span class="op">&lt;*</span> spaces <span class="op">&lt;*&gt;</span> many alpha</span></code></pre></div>
<p>Admittedly this example is not the best one and doesn’t show the full power of parser combinators. We need some additional combinators to gain more <strong><em>power</em></strong> to see what they are really capable of. But that is a challenge we will tackle in part 2 of this series of posts.</p>
<p>Thank you for reading, hope you enjoyed. Have a nice day, and until next time! - Joona</p>

    </main>

    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a> | Source code is available
      at
      <a href="https://github.com/japiirainen/japiirainen.github.io">GitHub</a>
    </footer>
  </body>
</html>
